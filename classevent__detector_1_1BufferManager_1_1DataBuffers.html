<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>event_detector: event_detector::BufferManager::DataBuffers&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">event_detector<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceevent__detector.html">event_detector</a></li><li class="navelem"><a class="el" href="classevent__detector_1_1BufferManager.html">BufferManager</a></li><li class="navelem"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">DataBuffers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classevent__detector_1_1BufferManager_1_1DataBuffers-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">event_detector::BufferManager::DataBuffers&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Template class designed to hold all buffers for a specific data type.  
 <a href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BufferManager_8hpp_source.html">BufferManager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aacad96ac5937474109dfdbd20cc4c8c5" id="r_aacad96ac5937474109dfdbd20cc4c8c5"><td class="memItemLeft" align="right" valign="top"><a id="aacad96ac5937474109dfdbd20cc4c8c5" name="aacad96ac5937474109dfdbd20cc4c8c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DataBuffers</b> ()</td></tr>
<tr class="memdesc:aacad96ac5937474109dfdbd20cc4c8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html" title="Template class designed to hold all buffers for a specific data type.">DataBuffers</a> instance. <br /></td></tr>
<tr class="separator:aacad96ac5937474109dfdbd20cc4c8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8678515c09c5ebae8e36b0c2832176" id="r_a2a8678515c09c5ebae8e36b0c2832176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a2a8678515c09c5ebae8e36b0c2832176">setBufferManager</a> (<a class="el" href="classevent__detector_1_1BufferManager.html">BufferManager</a> *manager)</td></tr>
<tr class="memdesc:a2a8678515c09c5ebae8e36b0c2832176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the managing <a class="el" href="classevent__detector_1_1BufferManager.html" title="Component of the Event Detector responsible for buffering live data.">BufferManager</a>.  <br /></td></tr>
<tr class="separator:a2a8678515c09c5ebae8e36b0c2832176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06d36a4691bc76b30640554913aae1b" id="r_af06d36a4691bc76b30640554913aae1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#af06d36a4691bc76b30640554913aae1b">update</a> (const std::vector&lt; <a class="el" href="structevent__detector_1_1ClientConnection.html">ClientConnection</a> &gt; &amp;clients)</td></tr>
<tr class="memdesc:af06d36a4691bc76b30640554913aae1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates buffers and mutexes for topics mentioned in clients. If a buffer and mutex already exists for a topic, the old buffer and mutex will be retained and no new buffer and mutex will be created. Existing mutexes and buffers for topics that are not mentioned in clients will be deleted.  <br /></td></tr>
<tr class="separator:af06d36a4691bc76b30640554913aae1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe39a8649a42a8d59f22d12249ccb00" id="r_a5fe39a8649a42a8d59f22d12249ccb00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a5fe39a8649a42a8d59f22d12249ccb00">insert</a> (const typename std::shared_ptr&lt; const T &gt; &amp;sample, const rclcpp::Time &amp;stamp, const std::string &amp;client_id, const std::string &amp;topic, const bool clear_if_time_is_running_backwards=true)</td></tr>
<tr class="memdesc:a5fe39a8649a42a8d59f22d12249ccb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new ROS message into the buffer.  <br /></td></tr>
<tr class="separator:a5fe39a8649a42a8d59f22d12249ccb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98514fb5a17264394441a9639f97171d" id="r_a98514fb5a17264394441a9639f97171d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a98514fb5a17264394441a9639f97171d">getClients</a> ()</td></tr>
<tr class="memdesc:a98514fb5a17264394441a9639f97171d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the clients IDs that have buffered data.  <br /></td></tr>
<tr class="separator:a98514fb5a17264394441a9639f97171d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450882801de88bcbca060e0aa1c4f975" id="r_a450882801de88bcbca060e0aa1c4f975"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a450882801de88bcbca060e0aa1c4f975">getFrames</a> (const std::string &amp;client_id)</td></tr>
<tr class="memdesc:a450882801de88bcbca060e0aa1c4f975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the frame IDs for a specific client that has buffered data.  <br /></td></tr>
<tr class="separator:a450882801de88bcbca060e0aa1c4f975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2893e87a2bbbf9aedd6f5a1ae224ec" id="r_a7c2893e87a2bbbf9aedd6f5a1ae224ec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structevent__detector_1_1Stamped.html">Stamped</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a7c2893e87a2bbbf9aedd6f5a1ae224ec">get</a> (const std::string &amp;client_id=&quot;&quot;, const std::string &amp;frame_id=&quot;&quot;, const std::string &amp;topic=&quot;&quot;)</td></tr>
<tr class="memdesc:a7c2893e87a2bbbf9aedd6f5a1ae224ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches all buffer samples.  <br /></td></tr>
<tr class="separator:a7c2893e87a2bbbf9aedd6f5a1ae224ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600073185866dc5896f25af988850c2d" id="r_a600073185866dc5896f25af988850c2d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structevent__detector_1_1Stamped.html">Stamped</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a600073185866dc5896f25af988850c2d">get</a> (const int k, const std::string &amp;client_id=&quot;&quot;, const std::string &amp;frame_id=&quot;&quot;, const std::string &amp;topic=&quot;&quot;)</td></tr>
<tr class="memdesc:a600073185866dc5896f25af988850c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches most recent k buffer samples.  <br /></td></tr>
<tr class="separator:a600073185866dc5896f25af988850c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9498b7f4320aca1c4332fbbf60e466ae" id="r_a9498b7f4320aca1c4332fbbf60e466ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structevent__detector_1_1Stamped.html">Stamped</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a9498b7f4320aca1c4332fbbf60e466ae">get</a> (const rclcpp::Time &amp;start_time, const rclcpp::Time &amp;end_time, const std::string &amp;client_id=&quot;&quot;, const std::string &amp;frame_id=&quot;&quot;, const std::string &amp;topic=&quot;&quot;)</td></tr>
<tr class="memdesc:a9498b7f4320aca1c4332fbbf60e466ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches all buffer samples within specified timeframe.  <br /></td></tr>
<tr class="separator:a9498b7f4320aca1c4332fbbf60e466ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c86857f7dad4646a0db3ac781152a1e" id="r_a5c86857f7dad4646a0db3ac781152a1e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structevent__detector_1_1Stamped.html">Stamped</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a5c86857f7dad4646a0db3ac781152a1e">get</a> (const int k, const rclcpp::Time &amp;start_time, const rclcpp::Time &amp;end_time, const std::string &amp;client_id=&quot;&quot;, const std::string &amp;frame_id=&quot;&quot;, const std::string &amp;topic=&quot;&quot;)</td></tr>
<tr class="memdesc:a5c86857f7dad4646a0db3ac781152a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches most recent k buffer samples within specified timeframe.  <br /></td></tr>
<tr class="separator:a5c86857f7dad4646a0db3ac781152a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b4fb59217efcc4c4a2df9ead6e3fa3" id="r_a18b4fb59217efcc4c4a2df9ead6e3fa3"><td class="memItemLeft" align="right" valign="top">string_map&lt; std::vector&lt; <a class="el" href="structevent__detector_1_1Stamped.html">Stamped</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a18b4fb59217efcc4c4a2df9ead6e3fa3">getWithTopic</a> (const int k, const rclcpp::Time &amp;start_time, const rclcpp::Time &amp;end_time, const std::string &amp;client_id=&quot;&quot;, const std::string &amp;frame_id=&quot;&quot;, const std::string &amp;topic=&quot;&quot;)</td></tr>
<tr class="memdesc:a18b4fb59217efcc4c4a2df9ead6e3fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as corresponding <code>get</code>, but returns samples grouped by topic.  <br /></td></tr>
<tr class="separator:a18b4fb59217efcc4c4a2df9ead6e3fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17695010cc0d77194fb34ab66ad7dbcc" id="r_a17695010cc0d77194fb34ab66ad7dbcc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a17695010cc0d77194fb34ab66ad7dbcc">getInfo</a> () const</td></tr>
<tr class="memdesc:a17695010cc0d77194fb34ab66ad7dbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of the buffers that are currently present.  <br /></td></tr>
<tr class="separator:a17695010cc0d77194fb34ab66ad7dbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7038a6eb79657484267dedeb928758c3" id="r_a7038a6eb79657484267dedeb928758c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a7038a6eb79657484267dedeb928758c3">clearBuffer</a> (const std::string &amp;client_id, const std::string &amp;topic)</td></tr>
<tr class="memdesc:a7038a6eb79657484267dedeb928758c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears buffer for a specific client and topic.  <br /></td></tr>
<tr class="separator:a7038a6eb79657484267dedeb928758c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798d5978216016202cdc83cecd9d536f" id="r_a798d5978216016202cdc83cecd9d536f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a798d5978216016202cdc83cecd9d536f">timeIsRunningBackwards</a> (const std::string &amp;client_id, const std::string &amp;topic, const rclcpp::Time &amp;stamp)</td></tr>
<tr class="memdesc:a798d5978216016202cdc83cecd9d536f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether time is running backwards for a specific client and topic.  <br /></td></tr>
<tr class="separator:a798d5978216016202cdc83cecd9d536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab1099dad324facc99a8ee752b1177323" id="r_ab1099dad324facc99a8ee752b1177323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classevent__detector_1_1BufferManager.html">BufferManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#ab1099dad324facc99a8ee752b1177323">manager_</a> = nullptr</td></tr>
<tr class="memdesc:ab1099dad324facc99a8ee752b1177323"><td class="mdescLeft">&#160;</td><td class="mdescRight">managing <a class="el" href="classevent__detector_1_1BufferManager.html" title="Component of the Event Detector responsible for buffering live data.">BufferManager</a>  <br /></td></tr>
<tr class="separator:ab1099dad324facc99a8ee752b1177323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9f66263e97c37888f76521461f60ae" id="r_a2e9f66263e97c37888f76521461f60ae"><td class="memItemLeft" align="right" valign="top">string_map_2d&lt; <a class="el" href="classDifferenceBasedBuffer.html">Buffer</a>&lt; std::shared_ptr&lt; const T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a2e9f66263e97c37888f76521461f60ae">buffer_by_client_topic_</a></td></tr>
<tr class="memdesc:a2e9f66263e97c37888f76521461f60ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">container for data buffers, stored by client ID and topic  <br /></td></tr>
<tr class="separator:a2e9f66263e97c37888f76521461f60ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747b2cad67ffca62031535e240cf567d" id="r_a747b2cad67ffca62031535e240cf567d"><td class="memItemLeft" align="right" valign="top">string_map_2d&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a747b2cad67ffca62031535e240cf567d">frame_by_client_topic_</a></td></tr>
<tr class="memdesc:a747b2cad67ffca62031535e240cf567d"><td class="mdescLeft">&#160;</td><td class="mdescRight">container to store frame ID by client ID and topic  <br /></td></tr>
<tr class="separator:a747b2cad67ffca62031535e240cf567d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118cd9e6694579368be7acb092c23ff5" id="r_a118cd9e6694579368be7acb092c23ff5"><td class="memItemLeft" align="right" valign="top">string_map_2d&lt; rclcpp::Time &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a118cd9e6694579368be7acb092c23ff5">last_stamp_by_client_topic_</a></td></tr>
<tr class="memdesc:a118cd9e6694579368be7acb092c23ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">container to store the last time stamp for each client and topic  <br /></td></tr>
<tr class="separator:a118cd9e6694579368be7acb092c23ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14dc2a9ba9a610a2e2335d84a572952" id="r_aa14dc2a9ba9a610a2e2335d84a572952"><td class="memItemLeft" align="right" valign="top">string_map_2d&lt; std::shared_ptr&lt; std::shared_mutex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#aa14dc2a9ba9a610a2e2335d84a572952">mutex_by_client_topic_</a></td></tr>
<tr class="memdesc:aa14dc2a9ba9a610a2e2335d84a572952"><td class="mdescLeft">&#160;</td><td class="mdescRight">container to store mutexes for locking buffer access  <br /></td></tr>
<tr class="separator:aa14dc2a9ba9a610a2e2335d84a572952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2b2a9214092871f49295cdfaa7955b" id="r_a2f2b2a9214092871f49295cdfaa7955b"><td class="memItemLeft" align="right" valign="top">std::shared_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html#a2f2b2a9214092871f49295cdfaa7955b">reconfigure_mutex_</a></td></tr>
<tr class="separator:a2f2b2a9214092871f49295cdfaa7955b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class event_detector::BufferManager::DataBuffers&lt; T &gt;</div><p>Template class designed to hold all buffers for a specific data type. </p>
<p>An instance of this class manages the buffers for multiple clients / frames for a specific data type. It provides multiple generic getter functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>ROS data type to buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="BufferManager_8hpp_source.html#l00066">66</a> of file <a class="el" href="BufferManager_8hpp_source.html">BufferManager.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7038a6eb79657484267dedeb928758c3" name="a7038a6eb79657484267dedeb928758c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7038a6eb79657484267dedeb928758c3">&#9670;&#160;</a></span>clearBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::clearBuffer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears buffer for a specific client and topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>client ID </td></tr>
    <tr><td class="paramname">topic</td><td>topic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c86857f7dad4646a0db3ac781152a1e" name="a5c86857f7dad4646a0db3ac781152a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c86857f7dad4646a0db3ac781152a1e">&#9670;&#160;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structevent__detector_1_1Stamped.html">Stamped</a>&lt; T &gt; &gt; <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>end_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>client_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frame_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches most recent k buffer samples within specified timeframe. </p>
<p>If <code>end_time</code> is 0, time filter is not used. If <code>k</code> is negative, no limit on the number of samples is imposed.</p>
<p>If no client or frame ID is given, data from all clients/frames is returned.</p>
<p>The returned data samples are stamped and sorted in ascending order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>how many recent samples to return </td></tr>
    <tr><td class="paramname">start_time</td><td>starting time filter </td></tr>
    <tr><td class="paramname">end_time</td><td>ending time filter </td></tr>
    <tr><td class="paramname">client_id</td><td>client ID (optional) </td></tr>
    <tr><td class="paramname">frame_id</td><td>frame ID (optional) </td></tr>
    <tr><td class="paramname">topic</td><td>topic (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Stamped&lt;T&gt;&gt; data samples </dd></dl>

</div>
</div>
<a id="a600073185866dc5896f25af988850c2d" name="a600073185866dc5896f25af988850c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600073185866dc5896f25af988850c2d">&#9670;&#160;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structevent__detector_1_1Stamped.html">Stamped</a>&lt; T &gt; &gt; <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>client_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frame_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches most recent k buffer samples. </p>
<p>If <code>k</code> is negative, no limit on the number of samples is imposed.</p>
<p>If no client or frame ID is given, data from all clients/frames is returned.</p>
<p>The returned data samples are stamped and sorted in ascending order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>how many recent samples to return </td></tr>
    <tr><td class="paramname">client_id</td><td>client ID (optional) </td></tr>
    <tr><td class="paramname">frame_id</td><td>frame ID (optional) </td></tr>
    <tr><td class="paramname">topic</td><td>topic (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Stamped&lt;T&gt;&gt; data samples </dd></dl>

</div>
</div>
<a id="a9498b7f4320aca1c4332fbbf60e466ae" name="a9498b7f4320aca1c4332fbbf60e466ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9498b7f4320aca1c4332fbbf60e466ae">&#9670;&#160;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structevent__detector_1_1Stamped.html">Stamped</a>&lt; T &gt; &gt; <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>end_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>client_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frame_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches all buffer samples within specified timeframe. </p>
<p>If <code>end_time</code> is 0, time filter is not used.</p>
<p>If no client or frame ID is given, data from all clients/frames is returned.</p>
<p>The returned data samples are stamped and sorted in ascending order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_time</td><td>starting time filter </td></tr>
    <tr><td class="paramname">end_time</td><td>ending time filter </td></tr>
    <tr><td class="paramname">client_id</td><td>client ID (optional) </td></tr>
    <tr><td class="paramname">frame_id</td><td>frame ID (optional) </td></tr>
    <tr><td class="paramname">topic</td><td>topic (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Stamped&lt;T&gt;&gt; data samples </dd></dl>

</div>
</div>
<a id="a7c2893e87a2bbbf9aedd6f5a1ae224ec" name="a7c2893e87a2bbbf9aedd6f5a1ae224ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2893e87a2bbbf9aedd6f5a1ae224ec">&#9670;&#160;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structevent__detector_1_1Stamped.html">Stamped</a>&lt; T &gt; &gt; <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>client_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frame_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches all buffer samples. </p>
<p>If no client or frame ID is given, data from all clients/frames is returned.</p>
<p>The returned data samples are stamped and sorted in ascending order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>client ID (optional) </td></tr>
    <tr><td class="paramname">frame_id</td><td>frame ID (optional) </td></tr>
    <tr><td class="paramname">topic</td><td>topic (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Stamped&lt;T&gt;&gt; data samples </dd></dl>

</div>
</div>
<a id="a98514fb5a17264394441a9639f97171d" name="a98514fb5a17264394441a9639f97171d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98514fb5a17264394441a9639f97171d">&#9670;&#160;</a></span>getClients()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::getClients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the clients IDs that have buffered data. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::string&gt; client IDs </dd></dl>

</div>
</div>
<a id="a450882801de88bcbca060e0aa1c4f975" name="a450882801de88bcbca060e0aa1c4f975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450882801de88bcbca060e0aa1c4f975">&#9670;&#160;</a></span>getFrames()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::getFrames </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>client_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the frame IDs for a specific client that has buffered data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>client ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::string&gt; frame IDs </dd></dl>

</div>
</div>
<a id="a17695010cc0d77194fb34ab66ad7dbcc" name="a17695010cc0d77194fb34ab66ad7dbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17695010cc0d77194fb34ab66ad7dbcc">&#9670;&#160;</a></span>getInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::getInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of the buffers that are currently present. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string string representation of the buffers </dd></dl>

</div>
</div>
<a id="a18b4fb59217efcc4c4a2df9ead6e3fa3" name="a18b4fb59217efcc4c4a2df9ead6e3fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b4fb59217efcc4c4a2df9ead6e3fa3">&#9670;&#160;</a></span>getWithTopic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">string_map&lt; std::vector&lt; <a class="el" href="structevent__detector_1_1Stamped.html">Stamped</a>&lt; T &gt; &gt; &gt; <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::getWithTopic </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>end_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>client_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frame_id</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as corresponding <code>get</code>, but returns samples grouped by topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_time</td><td>starting time filter </td></tr>
    <tr><td class="paramname">end_time</td><td>ending time filter </td></tr>
    <tr><td class="paramname">client_id</td><td>client ID (optional) </td></tr>
    <tr><td class="paramname">frame_id</td><td>frame ID (optional) </td></tr>
    <tr><td class="paramname">topic</td><td>topic (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string_map&lt;std::vector&lt;Stamped&lt;T&gt;&gt;&gt; data samples by topic </dd></dl>

</div>
</div>
<a id="a5fe39a8649a42a8d59f22d12249ccb00" name="a5fe39a8649a42a8d59f22d12249ccb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe39a8649a42a8d59f22d12249ccb00">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const typename std::shared_ptr&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>stamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clear_if_time_is_running_backwards</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new ROS message into the buffer. </p>
<p>May be used as a ROS subscription callback. Buffer has to be initialized before first insertion. Supports ROS messages with or without header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>new data message </td></tr>
    <tr><td class="paramname">stamp</td><td>ROS time stamp associated with the message </td></tr>
    <tr><td class="paramname">client_id</td><td>client ID </td></tr>
    <tr><td class="paramname">topic</td><td>ROS topic </td></tr>
    <tr><td class="paramname">clear_if_time_is_running_backwards</td><td>whether to clear the buffer if time is running backwards </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a8678515c09c5ebae8e36b0c2832176" name="a2a8678515c09c5ebae8e36b0c2832176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8678515c09c5ebae8e36b0c2832176">&#9670;&#160;</a></span>setBufferManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::setBufferManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevent__detector_1_1BufferManager.html">BufferManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the managing <a class="el" href="classevent__detector_1_1BufferManager.html" title="Component of the Event Detector responsible for buffering live data.">BufferManager</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td><a class="el" href="classevent__detector_1_1BufferManager.html" title="Component of the Event Detector responsible for buffering live data.">BufferManager</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a798d5978216016202cdc83cecd9d536f" name="a798d5978216016202cdc83cecd9d536f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798d5978216016202cdc83cecd9d536f">&#9670;&#160;</a></span>timeIsRunningBackwards()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::timeIsRunningBackwards </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>stamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether time is running backwards for a specific client and topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>client ID </td></tr>
    <tr><td class="paramname">topic</td><td>topic </td></tr>
    <tr><td class="paramname">stamp</td><td>stamp to compare with the last known time stamp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool whether time is running backwards </dd></dl>

</div>
</div>
<a id="af06d36a4691bc76b30640554913aae1b" name="af06d36a4691bc76b30640554913aae1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06d36a4691bc76b30640554913aae1b">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structevent__detector_1_1ClientConnection.html">ClientConnection</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clients</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates buffers and mutexes for topics mentioned in clients. If a buffer and mutex already exists for a topic, the old buffer and mutex will be retained and no new buffer and mutex will be created. Existing mutexes and buffers for topics that are not mentioned in clients will be deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clients</td><td>client connections for which to set up buffers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2e9f66263e97c37888f76521461f60ae" name="a2e9f66263e97c37888f76521461f60ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9f66263e97c37888f76521461f60ae">&#9670;&#160;</a></span>buffer_by_client_topic_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string_map_2d&lt;<a class="el" href="classDifferenceBasedBuffer.html">Buffer</a>&lt;std::shared_ptr&lt;const T&gt; &gt; &gt; <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::buffer_by_client_topic_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>container for data buffers, stored by client ID and topic </p>

<p class="definition">Definition at line <a class="el" href="BufferManager_8hpp_source.html#l00256">256</a> of file <a class="el" href="BufferManager_8hpp_source.html">BufferManager.hpp</a>.</p>

</div>
</div>
<a id="a747b2cad67ffca62031535e240cf567d" name="a747b2cad67ffca62031535e240cf567d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747b2cad67ffca62031535e240cf567d">&#9670;&#160;</a></span>frame_by_client_topic_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string_map_2d&lt;std::string&gt; <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::frame_by_client_topic_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>container to store frame ID by client ID and topic </p>

<p class="definition">Definition at line <a class="el" href="BufferManager_8hpp_source.html#l00261">261</a> of file <a class="el" href="BufferManager_8hpp_source.html">BufferManager.hpp</a>.</p>

</div>
</div>
<a id="a118cd9e6694579368be7acb092c23ff5" name="a118cd9e6694579368be7acb092c23ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118cd9e6694579368be7acb092c23ff5">&#9670;&#160;</a></span>last_stamp_by_client_topic_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string_map_2d&lt;rclcpp::Time&gt; <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::last_stamp_by_client_topic_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>container to store the last time stamp for each client and topic </p>

<p class="definition">Definition at line <a class="el" href="BufferManager_8hpp_source.html#l00266">266</a> of file <a class="el" href="BufferManager_8hpp_source.html">BufferManager.hpp</a>.</p>

</div>
</div>
<a id="ab1099dad324facc99a8ee752b1177323" name="ab1099dad324facc99a8ee752b1177323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1099dad324facc99a8ee752b1177323">&#9670;&#160;</a></span>manager_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevent__detector_1_1BufferManager.html">BufferManager</a>* <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::manager_ = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>managing <a class="el" href="classevent__detector_1_1BufferManager.html" title="Component of the Event Detector responsible for buffering live data.">BufferManager</a> </p>

<p class="definition">Definition at line <a class="el" href="BufferManager_8hpp_source.html#l00251">251</a> of file <a class="el" href="BufferManager_8hpp_source.html">BufferManager.hpp</a>.</p>

</div>
</div>
<a id="aa14dc2a9ba9a610a2e2335d84a572952" name="aa14dc2a9ba9a610a2e2335d84a572952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14dc2a9ba9a610a2e2335d84a572952">&#9670;&#160;</a></span>mutex_by_client_topic_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string_map_2d&lt;std::shared_ptr&lt;std::shared_mutex&gt; &gt; <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::mutex_by_client_topic_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>container to store mutexes for locking buffer access </p>

<p class="definition">Definition at line <a class="el" href="BufferManager_8hpp_source.html#l00271">271</a> of file <a class="el" href="BufferManager_8hpp_source.html">BufferManager.hpp</a>.</p>

</div>
</div>
<a id="a2f2b2a9214092871f49295cdfaa7955b" name="a2f2b2a9214092871f49295cdfaa7955b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2b2a9214092871f49295cdfaa7955b">&#9670;&#160;</a></span>reconfigure_mutex_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_mutex <a class="el" href="classevent__detector_1_1BufferManager_1_1DataBuffers.html">event_detector::BufferManager::DataBuffers</a>&lt; T &gt;::reconfigure_mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>mutex for reconfiguration </p>

<p class="definition">Definition at line <a class="el" href="BufferManager_8hpp_source.html#l00276">276</a> of file <a class="el" href="BufferManager_8hpp_source.html">BufferManager.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>event_detector/include/event_detector/<a class="el" href="BufferManager_8hpp_source.html">BufferManager.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
